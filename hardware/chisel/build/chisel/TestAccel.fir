;buildInfoPackage: chisel3, version: 3.1.8, scalaVersion: 2.11.12, sbtVersion: 1.1.1, builtAtString: 2019-07-08 17:44:42.884, builtAtMillis: 1562607882884
circuit TestAccel : 
  extmodule VTASimDPI : 
    output dpi_wait : UInt<1>
    input reset : UInt<1>
    input clock : Clock
    
    defname = VTASimDPI
    
    
  extmodule VTAHostDPI : 
    output dpi : {req : {valid : UInt<1>, opcode : UInt<1>, addr : UInt<8>, value : UInt<32>, flip deq : UInt<1>}, flip resp : {valid : UInt<1>, bits : UInt<32>}}
    input reset : UInt<1>
    input clock : Clock
    
    defname = VTAHostDPI
    
    
  extmodule VTAMemDPI : 
    output dpi : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip len : UInt<8>, flip addr : UInt<64>}, flip wr : {valid : UInt<1>, bits : UInt<64>}, rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}
    input reset : UInt<1>
    input clock : Clock
    
    defname = VTAMemDPI
    
    
  module VTASimShell : 
    input clock : Clock
    input reset : UInt<1>
    output host : {req : {valid : UInt<1>, opcode : UInt<1>, addr : UInt<8>, value : UInt<32>, flip deq : UInt<1>}, flip resp : {valid : UInt<1>, bits : UInt<32>}}
    output mem : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip len : UInt<8>, flip addr : UInt<64>}, flip wr : {valid : UInt<1>, bits : UInt<64>}, rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}
    input sim_clock : Clock
    output sim_wait : UInt<1>
    
    inst mod_sim of VTASimDPI @[TestAccel.scala 37:23]
    mod_sim.dpi_wait is invalid
    mod_sim.reset is invalid
    mod_sim.clock is invalid
    inst mod_host of VTAHostDPI @[TestAccel.scala 38:24]
    mod_host.dpi is invalid
    mod_host.reset is invalid
    mod_host.clock is invalid
    inst mod_mem of VTAMemDPI @[TestAccel.scala 39:23]
    mod_mem.dpi is invalid
    mod_mem.reset is invalid
    mod_mem.clock is invalid
    mod_mem.clock <= clock @[TestAccel.scala 40:20]
    mod_mem.reset <= reset @[TestAccel.scala 41:20]
    mem.rd.bits <= mod_mem.dpi.rd.bits @[TestAccel.scala 42:18]
    mem.rd.valid <= mod_mem.dpi.rd.valid @[TestAccel.scala 42:18]
    mod_mem.dpi.rd.ready <= mem.rd.ready @[TestAccel.scala 42:18]
    mod_mem.dpi.wr.bits <= mem.wr.bits @[TestAccel.scala 42:18]
    mod_mem.dpi.wr.valid <= mem.wr.valid @[TestAccel.scala 42:18]
    mod_mem.dpi.req.addr <= mem.req.addr @[TestAccel.scala 42:18]
    mod_mem.dpi.req.len <= mem.req.len @[TestAccel.scala 42:18]
    mod_mem.dpi.req.opcode <= mem.req.opcode @[TestAccel.scala 42:18]
    mod_mem.dpi.req.valid <= mem.req.valid @[TestAccel.scala 42:18]
    mod_host.clock <= clock @[TestAccel.scala 43:21]
    mod_host.reset <= reset @[TestAccel.scala 44:21]
    mod_host.dpi.resp.bits <= host.resp.bits @[TestAccel.scala 45:8]
    mod_host.dpi.resp.valid <= host.resp.valid @[TestAccel.scala 45:8]
    mod_host.dpi.req.deq <= host.req.deq @[TestAccel.scala 45:8]
    host.req.value <= mod_host.dpi.req.value @[TestAccel.scala 45:8]
    host.req.addr <= mod_host.dpi.req.addr @[TestAccel.scala 45:8]
    host.req.opcode <= mod_host.dpi.req.opcode @[TestAccel.scala 45:8]
    host.req.valid <= mod_host.dpi.req.valid @[TestAccel.scala 45:8]
    mod_sim.clock <= sim_clock @[TestAccel.scala 46:20]
    mod_sim.reset <= reset @[TestAccel.scala 47:20]
    sim_wait <= mod_sim.dpi_wait @[TestAccel.scala 48:12]
    
  module RegFile : 
    input clock : Clock
    input reset : UInt<1>
    output io : {launch : UInt<1>, flip finish : UInt<1>, flip ecnt : {valid : UInt<1>, bits : UInt<32>}[1], vals : UInt<32>[2], ptrs : UInt<64>[2], host : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip addr : UInt<8>, flip value : UInt<32>, deq : UInt<1>}, resp : {valid : UInt<1>, bits : UInt<32>}}}
    
    reg state : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[RegFile.scala 60:22]
    node _T_68 = eq(UInt<1>("h00"), state) @[Conditional.scala 37:30]
    when _T_68 : @[Conditional.scala 40:58]
      node _T_70 = eq(io.host.req.opcode, UInt<1>("h00")) @[RegFile.scala 64:33]
      node _T_71 = and(io.host.req.valid, _T_70) @[RegFile.scala 64:30]
      when _T_71 : @[RegFile.scala 64:54]
        state <= UInt<1>("h01") @[RegFile.scala 65:15]
        skip @[RegFile.scala 64:54]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_72 = eq(UInt<1>("h01"), state) @[Conditional.scala 37:30]
      when _T_72 : @[Conditional.scala 39:67]
        state <= UInt<1>("h00") @[RegFile.scala 69:13]
        skip @[Conditional.scala 39:67]
    node _T_73 = eq(state, UInt<1>("h00")) @[RegFile.scala 73:28]
    node _T_74 = and(_T_73, io.host.req.valid) @[RegFile.scala 73:38]
    io.host.req.deq <= _T_74 @[RegFile.scala 73:19]
    wire _T_78 : UInt<32> @[RegFile.scala 77:42]
    _T_78 <= UInt<1>("h00") @[RegFile.scala 77:42]
    reg reg_0 : UInt, clock with : (reset => (reset, _T_78)) @[RegFile.scala 77:29]
    wire _T_83 : UInt<32> @[RegFile.scala 77:42]
    _T_83 <= UInt<1>("h00") @[RegFile.scala 77:42]
    reg reg_1 : UInt, clock with : (reset => (reset, _T_83)) @[RegFile.scala 77:29]
    wire _T_88 : UInt<32> @[RegFile.scala 77:42]
    _T_88 <= UInt<1>("h00") @[RegFile.scala 77:42]
    reg reg_2 : UInt, clock with : (reset => (reset, _T_88)) @[RegFile.scala 77:29]
    wire _T_93 : UInt<32> @[RegFile.scala 77:42]
    _T_93 <= UInt<1>("h00") @[RegFile.scala 77:42]
    reg reg_3 : UInt, clock with : (reset => (reset, _T_93)) @[RegFile.scala 77:29]
    wire _T_98 : UInt<32> @[RegFile.scala 77:42]
    _T_98 <= UInt<1>("h00") @[RegFile.scala 77:42]
    reg reg_4 : UInt, clock with : (reset => (reset, _T_98)) @[RegFile.scala 77:29]
    wire _T_103 : UInt<32> @[RegFile.scala 77:42]
    _T_103 <= UInt<1>("h00") @[RegFile.scala 77:42]
    reg reg_5 : UInt, clock with : (reset => (reset, _T_103)) @[RegFile.scala 77:29]
    wire _T_108 : UInt<32> @[RegFile.scala 77:42]
    _T_108 <= UInt<1>("h00") @[RegFile.scala 77:42]
    reg reg_6 : UInt, clock with : (reset => (reset, _T_108)) @[RegFile.scala 77:29]
    wire _T_113 : UInt<32> @[RegFile.scala 77:42]
    _T_113 <= UInt<1>("h00") @[RegFile.scala 77:42]
    reg reg_7 : UInt, clock with : (reset => (reset, _T_113)) @[RegFile.scala 77:29]
    when io.finish : @[RegFile.scala 84:19]
      reg_0 <= UInt<2>("h02") @[RegFile.scala 85:12]
      skip @[RegFile.scala 84:19]
    else : @[RegFile.scala 87:59]
      node _T_124 = eq(state, UInt<1>("h00")) @[RegFile.scala 86:20]
      node _T_125 = and(_T_124, io.host.req.valid) @[RegFile.scala 86:30]
      node _T_126 = and(_T_125, io.host.req.opcode) @[RegFile.scala 86:51]
      node _T_128 = eq(UInt<1>("h00"), io.host.req.addr) @[RegFile.scala 87:37]
      node _T_129 = and(_T_126, _T_128) @[RegFile.scala 87:24]
      when _T_129 : @[RegFile.scala 87:59]
        reg_0 <= io.host.req.value @[RegFile.scala 88:12]
        skip @[RegFile.scala 87:59]
    when io.ecnt[0].valid : @[RegFile.scala 92:28]
      reg_1 <= io.ecnt[0].bits @[RegFile.scala 93:19]
      skip @[RegFile.scala 92:28]
    else : @[RegFile.scala 95:66]
      node _T_130 = eq(state, UInt<1>("h00")) @[RegFile.scala 94:22]
      node _T_131 = and(_T_130, io.host.req.valid) @[RegFile.scala 94:32]
      node _T_132 = and(_T_131, io.host.req.opcode) @[RegFile.scala 94:53]
      node _T_134 = eq(UInt<3>("h04"), io.host.req.addr) @[RegFile.scala 95:44]
      node _T_135 = and(_T_132, _T_134) @[RegFile.scala 95:26]
      when _T_135 : @[RegFile.scala 95:66]
        reg_1 <= io.host.req.value @[RegFile.scala 96:19]
        skip @[RegFile.scala 95:66]
    node _T_136 = eq(state, UInt<1>("h00")) @[RegFile.scala 102:13]
    node _T_137 = and(_T_136, io.host.req.valid) @[RegFile.scala 102:23]
    node _T_138 = and(_T_137, io.host.req.opcode) @[RegFile.scala 102:44]
    node _T_140 = eq(UInt<4>("h08"), io.host.req.addr) @[RegFile.scala 103:46]
    node _T_141 = and(_T_138, _T_140) @[RegFile.scala 103:28]
    when _T_141 : @[RegFile.scala 103:68]
      reg_2 <= io.host.req.value @[RegFile.scala 104:19]
      skip @[RegFile.scala 103:68]
    node _T_142 = eq(state, UInt<1>("h00")) @[RegFile.scala 102:13]
    node _T_143 = and(_T_142, io.host.req.valid) @[RegFile.scala 102:23]
    node _T_144 = and(_T_143, io.host.req.opcode) @[RegFile.scala 102:44]
    node _T_146 = eq(UInt<4>("h0c"), io.host.req.addr) @[RegFile.scala 103:46]
    node _T_147 = and(_T_144, _T_146) @[RegFile.scala 103:28]
    when _T_147 : @[RegFile.scala 103:68]
      reg_3 <= io.host.req.value @[RegFile.scala 104:19]
      skip @[RegFile.scala 103:68]
    node _T_148 = eq(state, UInt<1>("h00")) @[RegFile.scala 102:13]
    node _T_149 = and(_T_148, io.host.req.valid) @[RegFile.scala 102:23]
    node _T_150 = and(_T_149, io.host.req.opcode) @[RegFile.scala 102:44]
    node _T_152 = eq(UInt<5>("h010"), io.host.req.addr) @[RegFile.scala 103:46]
    node _T_153 = and(_T_150, _T_152) @[RegFile.scala 103:28]
    when _T_153 : @[RegFile.scala 103:68]
      reg_4 <= io.host.req.value @[RegFile.scala 104:19]
      skip @[RegFile.scala 103:68]
    node _T_154 = eq(state, UInt<1>("h00")) @[RegFile.scala 102:13]
    node _T_155 = and(_T_154, io.host.req.valid) @[RegFile.scala 102:23]
    node _T_156 = and(_T_155, io.host.req.opcode) @[RegFile.scala 102:44]
    node _T_158 = eq(UInt<5>("h014"), io.host.req.addr) @[RegFile.scala 103:46]
    node _T_159 = and(_T_156, _T_158) @[RegFile.scala 103:28]
    when _T_159 : @[RegFile.scala 103:68]
      reg_5 <= io.host.req.value @[RegFile.scala 104:19]
      skip @[RegFile.scala 103:68]
    node _T_160 = eq(state, UInt<1>("h00")) @[RegFile.scala 102:13]
    node _T_161 = and(_T_160, io.host.req.valid) @[RegFile.scala 102:23]
    node _T_162 = and(_T_161, io.host.req.opcode) @[RegFile.scala 102:44]
    node _T_164 = eq(UInt<5>("h018"), io.host.req.addr) @[RegFile.scala 103:46]
    node _T_165 = and(_T_162, _T_164) @[RegFile.scala 103:28]
    when _T_165 : @[RegFile.scala 103:68]
      reg_6 <= io.host.req.value @[RegFile.scala 104:19]
      skip @[RegFile.scala 103:68]
    node _T_166 = eq(state, UInt<1>("h00")) @[RegFile.scala 102:13]
    node _T_167 = and(_T_166, io.host.req.valid) @[RegFile.scala 102:23]
    node _T_168 = and(_T_167, io.host.req.opcode) @[RegFile.scala 102:44]
    node _T_170 = eq(UInt<5>("h01c"), io.host.req.addr) @[RegFile.scala 103:46]
    node _T_171 = and(_T_168, _T_170) @[RegFile.scala 103:28]
    when _T_171 : @[RegFile.scala 103:68]
      reg_7 <= io.host.req.value @[RegFile.scala 104:19]
      skip @[RegFile.scala 103:68]
    wire _T_175 : UInt<32> @[RegFile.scala 108:35]
    _T_175 <= UInt<1>("h00") @[RegFile.scala 108:35]
    reg rdata : UInt, clock with : (reset => (reset, _T_175)) @[RegFile.scala 108:22]
    node _T_177 = eq(state, UInt<1>("h00")) @[RegFile.scala 109:14]
    node _T_178 = and(_T_177, io.host.req.valid) @[RegFile.scala 109:24]
    node _T_180 = eq(io.host.req.opcode, UInt<1>("h00")) @[RegFile.scala 109:48]
    node _T_181 = and(_T_178, _T_180) @[RegFile.scala 109:45]
    when _T_181 : @[RegFile.scala 109:69]
      node _T_183 = eq(UInt<5>("h01c"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_184 = mux(_T_183, reg_7, UInt<1>("h00")) @[Mux.scala 46:16]
      node _T_185 = eq(UInt<5>("h018"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_186 = mux(_T_185, reg_6, _T_184) @[Mux.scala 46:16]
      node _T_187 = eq(UInt<5>("h014"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_188 = mux(_T_187, reg_5, _T_186) @[Mux.scala 46:16]
      node _T_189 = eq(UInt<5>("h010"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_190 = mux(_T_189, reg_4, _T_188) @[Mux.scala 46:16]
      node _T_191 = eq(UInt<4>("h0c"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_192 = mux(_T_191, reg_3, _T_190) @[Mux.scala 46:16]
      node _T_193 = eq(UInt<4>("h08"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_194 = mux(_T_193, reg_2, _T_192) @[Mux.scala 46:16]
      node _T_195 = eq(UInt<3>("h04"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_196 = mux(_T_195, reg_1, _T_194) @[Mux.scala 46:16]
      node _T_197 = eq(UInt<1>("h00"), io.host.req.addr) @[Mux.scala 46:19]
      node _T_198 = mux(_T_197, reg_0, _T_196) @[Mux.scala 46:16]
      rdata <= _T_198 @[RegFile.scala 110:11]
      skip @[RegFile.scala 109:69]
    node _T_199 = eq(state, UInt<1>("h01")) @[RegFile.scala 113:31]
    io.host.resp.valid <= _T_199 @[RegFile.scala 113:22]
    io.host.resp.bits <= rdata @[RegFile.scala 114:21]
    node _T_200 = bits(reg_0, 0, 0) @[RegFile.scala 116:22]
    io.launch <= _T_200 @[RegFile.scala 116:13]
    io.vals[0] <= reg_2 @[RegFile.scala 119:16]
    io.vals[1] <= reg_3 @[RegFile.scala 119:16]
    node _T_201 = cat(reg_5, reg_4) @[Cat.scala 30:58]
    io.ptrs[0] <= _T_201 @[RegFile.scala 123:16]
    node _T_202 = cat(reg_7, reg_6) @[Cat.scala 30:58]
    io.ptrs[1] <= _T_202 @[RegFile.scala 123:16]
    
  module Compute : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip launch : UInt<1>, finish : UInt<1>, ecnt : {valid : UInt<1>, bits : UInt<32>}[1], flip vals : UInt<32>[2], flip ptrs : UInt<64>[2], mem : {req : {valid : UInt<1>, opcode : UInt<1>, len : UInt<8>, addr : UInt<64>}, wr : {valid : UInt<1>, bits : UInt<64>}, flip rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}}
    
    reg state : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Compute.scala 48:22]
    reg cycles : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[Compute.scala 51:23]
    reg reg : UInt<64>, clock @[Compute.scala 52:16]
    reg cnt : UInt<32>, clock @[Compute.scala 53:16]
    reg raddr : UInt<64>, clock @[Compute.scala 54:18]
    reg waddr : UInt<64>, clock @[Compute.scala 55:18]
    node _T_80 = eq(UInt<3>("h00"), state) @[Conditional.scala 37:30]
    when _T_80 : @[Conditional.scala 40:58]
      when io.launch : @[Compute.scala 59:23]
        state <= UInt<3>("h01") @[Compute.scala 60:15]
        skip @[Compute.scala 59:23]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_81 = eq(UInt<3>("h01"), state) @[Conditional.scala 37:30]
      when _T_81 : @[Conditional.scala 39:67]
        state <= UInt<3>("h02") @[Compute.scala 64:13]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_82 = eq(UInt<3>("h02"), state) @[Conditional.scala 37:30]
        when _T_82 : @[Conditional.scala 39:67]
          when io.mem.rd.valid : @[Compute.scala 67:29]
            state <= UInt<3>("h03") @[Compute.scala 68:15]
            skip @[Compute.scala 67:29]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_83 = eq(UInt<3>("h03"), state) @[Conditional.scala 37:30]
          when _T_83 : @[Conditional.scala 39:67]
            state <= UInt<3>("h04") @[Compute.scala 72:13]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_84 = eq(UInt<3>("h04"), state) @[Conditional.scala 37:30]
            when _T_84 : @[Conditional.scala 39:67]
              node _T_86 = sub(io.vals[1], UInt<1>("h01")) @[Compute.scala 75:28]
              node _T_87 = asUInt(_T_86) @[Compute.scala 75:28]
              node _T_88 = tail(_T_87, 1) @[Compute.scala 75:28]
              node _T_89 = eq(cnt, _T_88) @[Compute.scala 75:16]
              when _T_89 : @[Compute.scala 75:36]
                state <= UInt<3>("h00") @[Compute.scala 76:15]
                skip @[Compute.scala 75:36]
              else : @[Compute.scala 77:19]
                state <= UInt<3>("h01") @[Compute.scala 78:15]
                skip @[Compute.scala 77:19]
              skip @[Conditional.scala 39:67]
    node _T_90 = eq(state, UInt<3>("h04")) @[Compute.scala 83:20]
    node _T_92 = sub(io.vals[1], UInt<1>("h01")) @[Compute.scala 83:54]
    node _T_93 = asUInt(_T_92) @[Compute.scala 83:54]
    node _T_94 = tail(_T_93, 1) @[Compute.scala 83:54]
    node _T_95 = eq(cnt, _T_94) @[Compute.scala 83:42]
    node last = and(_T_90, _T_95) @[Compute.scala 83:35]
    node _T_96 = eq(state, UInt<3>("h00")) @[Compute.scala 86:14]
    when _T_96 : @[Compute.scala 86:25]
      cycles <= UInt<1>("h00") @[Compute.scala 87:12]
      skip @[Compute.scala 86:25]
    else : @[Compute.scala 88:15]
      node _T_99 = add(cycles, UInt<1>("h01")) @[Compute.scala 89:22]
      node _T_100 = tail(_T_99, 1) @[Compute.scala 89:22]
      cycles <= _T_100 @[Compute.scala 89:12]
      skip @[Compute.scala 88:15]
    io.ecnt[0].valid <= last @[Compute.scala 92:20]
    io.ecnt[0].bits <= cycles @[Compute.scala 93:19]
    node _T_101 = eq(state, UInt<3>("h00")) @[Compute.scala 96:14]
    when _T_101 : @[Compute.scala 96:25]
      raddr <= io.ptrs[0] @[Compute.scala 97:11]
      waddr <= io.ptrs[1] @[Compute.scala 98:11]
      skip @[Compute.scala 96:25]
    else : @[Compute.scala 99:36]
      node _T_102 = eq(state, UInt<3>("h04")) @[Compute.scala 99:20]
      when _T_102 : @[Compute.scala 99:36]
        node _T_104 = add(raddr, UInt<4>("h08")) @[Compute.scala 100:20]
        node _T_105 = tail(_T_104, 1) @[Compute.scala 100:20]
        raddr <= _T_105 @[Compute.scala 100:11]
        node _T_107 = add(waddr, UInt<4>("h08")) @[Compute.scala 101:20]
        node _T_108 = tail(_T_107, 1) @[Compute.scala 101:20]
        waddr <= _T_108 @[Compute.scala 101:11]
        skip @[Compute.scala 99:36]
    node _T_109 = eq(state, UInt<3>("h01")) @[Compute.scala 105:29]
    node _T_110 = eq(state, UInt<3>("h03")) @[Compute.scala 105:50]
    node _T_111 = or(_T_109, _T_110) @[Compute.scala 105:42]
    io.mem.req.valid <= _T_111 @[Compute.scala 105:20]
    node _T_112 = eq(state, UInt<3>("h03")) @[Compute.scala 106:30]
    io.mem.req.opcode <= _T_112 @[Compute.scala 106:21]
    io.mem.req.len <= UInt<1>("h00") @[Compute.scala 107:18]
    node _T_114 = eq(state, UInt<3>("h01")) @[Compute.scala 108:32]
    node _T_115 = mux(_T_114, raddr, waddr) @[Compute.scala 108:25]
    io.mem.req.addr <= _T_115 @[Compute.scala 108:19]
    node _T_116 = eq(state, UInt<3>("h02")) @[Compute.scala 111:14]
    node _T_117 = and(_T_116, io.mem.rd.valid) @[Compute.scala 111:28]
    when _T_117 : @[Compute.scala 111:48]
      node _T_118 = add(io.mem.rd.bits, io.vals[0]) @[Compute.scala 112:27]
      node _T_119 = tail(_T_118, 1) @[Compute.scala 112:27]
      reg <= _T_119 @[Compute.scala 112:9]
      skip @[Compute.scala 111:48]
    node _T_120 = eq(state, UInt<3>("h02")) @[Compute.scala 114:28]
    io.mem.rd.ready <= _T_120 @[Compute.scala 114:19]
    node _T_121 = eq(state, UInt<3>("h04")) @[Compute.scala 117:28]
    io.mem.wr.valid <= _T_121 @[Compute.scala 117:19]
    io.mem.wr.bits <= reg @[Compute.scala 118:18]
    node _T_122 = eq(state, UInt<3>("h00")) @[Compute.scala 121:14]
    when _T_122 : @[Compute.scala 121:25]
      cnt <= UInt<1>("h00") @[Compute.scala 122:9]
      skip @[Compute.scala 121:25]
    else : @[Compute.scala 123:36]
      node _T_124 = eq(state, UInt<3>("h04")) @[Compute.scala 123:20]
      when _T_124 : @[Compute.scala 123:36]
        node _T_126 = add(cnt, UInt<1>("h01")) @[Compute.scala 124:16]
        node _T_127 = tail(_T_126, 1) @[Compute.scala 124:16]
        cnt <= _T_127 @[Compute.scala 124:9]
        skip @[Compute.scala 123:36]
    io.finish <= last @[Compute.scala 128:13]
    
  module Accel : 
    input clock : Clock
    input reset : UInt<1>
    output io : {host : {req : {flip valid : UInt<1>, flip opcode : UInt<1>, flip addr : UInt<8>, flip value : UInt<32>, deq : UInt<1>}, resp : {valid : UInt<1>, bits : UInt<32>}}, mem : {req : {valid : UInt<1>, opcode : UInt<1>, len : UInt<8>, addr : UInt<64>}, wr : {valid : UInt<1>, bits : UInt<64>}, flip rd : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}}
    
    inst rf of RegFile @[Accel.scala 53:18]
    rf.clock <= clock
    rf.reset <= reset
    inst ce of Compute @[Accel.scala 54:18]
    ce.clock <= clock
    ce.reset <= reset
    io.host.resp.bits <= rf.io.host.resp.bits @[Accel.scala 55:14]
    io.host.resp.valid <= rf.io.host.resp.valid @[Accel.scala 55:14]
    io.host.req.deq <= rf.io.host.req.deq @[Accel.scala 55:14]
    rf.io.host.req.value <= io.host.req.value @[Accel.scala 55:14]
    rf.io.host.req.addr <= io.host.req.addr @[Accel.scala 55:14]
    rf.io.host.req.opcode <= io.host.req.opcode @[Accel.scala 55:14]
    rf.io.host.req.valid <= io.host.req.valid @[Accel.scala 55:14]
    ce.io.mem.rd.bits <= io.mem.rd.bits @[Accel.scala 56:10]
    ce.io.mem.rd.valid <= io.mem.rd.valid @[Accel.scala 56:10]
    io.mem.rd.ready <= ce.io.mem.rd.ready @[Accel.scala 56:10]
    io.mem.wr.bits <= ce.io.mem.wr.bits @[Accel.scala 56:10]
    io.mem.wr.valid <= ce.io.mem.wr.valid @[Accel.scala 56:10]
    io.mem.req.addr <= ce.io.mem.req.addr @[Accel.scala 56:10]
    io.mem.req.len <= ce.io.mem.req.len @[Accel.scala 56:10]
    io.mem.req.opcode <= ce.io.mem.req.opcode @[Accel.scala 56:10]
    io.mem.req.valid <= ce.io.mem.req.valid @[Accel.scala 56:10]
    ce.io.launch <= rf.io.launch @[Accel.scala 57:16]
    rf.io.finish <= ce.io.finish @[Accel.scala 58:16]
    rf.io.ecnt[0].bits <= ce.io.ecnt[0].bits @[Accel.scala 59:14]
    rf.io.ecnt[0].valid <= ce.io.ecnt[0].valid @[Accel.scala 59:14]
    ce.io.vals[0] <= rf.io.vals[0] @[Accel.scala 60:14]
    ce.io.vals[1] <= rf.io.vals[1] @[Accel.scala 60:14]
    ce.io.ptrs[0] <= rf.io.ptrs[0] @[Accel.scala 61:14]
    ce.io.ptrs[1] <= rf.io.ptrs[1] @[Accel.scala 61:14]
    
  module TestAccel : 
    input clock : Clock
    input reset : UInt<1>
    input sim_clock : Clock
    output sim_wait : UInt<1>
    
    inst sim_shell of VTASimShell @[TestAccel.scala 59:25]
    sim_shell.clock <= clock
    sim_shell.reset <= reset
    inst vta_accel of Accel @[TestAccel.scala 60:25]
    vta_accel.clock <= clock
    vta_accel.reset <= reset
    sim_shell.sim_clock <= sim_clock @[TestAccel.scala 61:23]
    sim_wait <= sim_shell.sim_wait @[TestAccel.scala 62:12]
    vta_accel.io.mem.rd.bits <= sim_shell.mem.rd.bits @[TestAccel.scala 63:17]
    vta_accel.io.mem.rd.valid <= sim_shell.mem.rd.valid @[TestAccel.scala 63:17]
    sim_shell.mem.rd.ready <= vta_accel.io.mem.rd.ready @[TestAccel.scala 63:17]
    sim_shell.mem.wr.bits <= vta_accel.io.mem.wr.bits @[TestAccel.scala 63:17]
    sim_shell.mem.wr.valid <= vta_accel.io.mem.wr.valid @[TestAccel.scala 63:17]
    sim_shell.mem.req.addr <= vta_accel.io.mem.req.addr @[TestAccel.scala 63:17]
    sim_shell.mem.req.len <= vta_accel.io.mem.req.len @[TestAccel.scala 63:17]
    sim_shell.mem.req.opcode <= vta_accel.io.mem.req.opcode @[TestAccel.scala 63:17]
    sim_shell.mem.req.valid <= vta_accel.io.mem.req.valid @[TestAccel.scala 63:17]
    sim_shell.host.resp.bits <= vta_accel.io.host.resp.bits @[TestAccel.scala 64:21]
    sim_shell.host.resp.valid <= vta_accel.io.host.resp.valid @[TestAccel.scala 64:21]
    sim_shell.host.req.deq <= vta_accel.io.host.req.deq @[TestAccel.scala 64:21]
    vta_accel.io.host.req.value <= sim_shell.host.req.value @[TestAccel.scala 64:21]
    vta_accel.io.host.req.addr <= sim_shell.host.req.addr @[TestAccel.scala 64:21]
    vta_accel.io.host.req.opcode <= sim_shell.host.req.opcode @[TestAccel.scala 64:21]
    vta_accel.io.host.req.valid <= sim_shell.host.req.valid @[TestAccel.scala 64:21]
    
